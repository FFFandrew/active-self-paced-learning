% %% 动态事件触发

%---------------------相关的参数重新设计------------------------

%--------------触发时刻的序列和状态的节点怎么去绘图-------------


function [dx] = ET(t,x,x0)
global trigger_times_1;
global trigger_times_2;
global trigger_times_3;
global trigger_times_4;
global trigger_times_5;
global trigger_times_6;
global trigger_times_7;
global trigger_times_8;
% global u;
% 
% global x1;

A=[0,1,0,0,0,0,0,0;
   0,0,1,0,0,0,0,0;
   0,0,0,1,0,0,0,0;
   0,0,0,0,1,0,0,0;
   0,0,0,0,0,1,0,0;
   0,0,0,0,0,0,1,0;
   0,0,0,0,0,0,0,1;
   1,0,0,0,0,0,0,0];%连接矩阵

% A=[0,1,0,0,0;
% 0,0,1,0,0;
% 0,0,0,1,0;
% 0,0,0,0,1;
% 1,0,0,0,0];%连接矩阵

N=8;

L =diag(A*ones(N,1))-A;%拉普拉斯矩阵


k=20;%\eta
T=2;%the setting time
h=30;
rou=0.3;%p
%b=0.35;%c
ant=[0.3;0.9;0.8;0.9;0.8;0.9;0.5;0.4];%\q
% on=[1;1;1;1;1;1];
% %f=(x-i).^4+8*(x-i).^2;%待优化函数
% x0 = [1.5;2.5;2;3.5;5.6;5.2;6.3;7.6];
% x0 = [1.5;2.5;2;3.5;5.6;5.2;6.3;7.6];
%x0 = [3;4.2;1.2;5.8;3.5;7.8;6;6.2];
%求导 这个diffresult 是二阶导数 即 Hessian
diffresult=[12*(x(1)-1)^2+16,12*(x(2)-2)^2+16,12*(x(3)-3)^2+16,12*(x(4)-4)^2+16,12*(x(5)-5)^2+16,12*(x(6)-6)^2+16,12*(x(7)-7)^2+16,12*(x(8)-8)^2+16];

H=diag(diffresult); % 这里把它做成Hessian
gi=[4*(x0(1)-1)^3+16*(x0(1)-1);4*(x0(2)-2)^3+16*(x0(2)-2);4*(x0(3)-3)^3+16*(x0(3)-3);4*(x0(4)-4)^3+16*(x0(4)-4);4*(x0(5)-5)^3+16*(x0(5)-5);4*(x0(6)-6)^3+16*(x0(6)-6);4*(x0(7)-7)^3+16*(x0(7)-7);4*(x0(8)-8)^3+16*(x0(8)-8)];
%一阶导数 gi=[4*(x(1)-1)^3+16*(x(1)-1);4*(x(2)-2)^3+16*(x(2)-2);4*(x(3)-3)^3+16*(x(3)-3);4*(x(4)-4)^3+16*(x(4)-4);4*(x(5)-5)^3+16*(x(5)-5);4*(x(6)-6)^3+16*(x(6)-6);4*(x(7)-7)^3+16*(x(7)-7);4*(x(8)-8)^3+16*(x(8)-8)];
% A = [0 1; -2 3];  %系统参数矩阵
% B = [0; 1];       %系统参数矩阵
% K = [1 -4];       %反馈矩阵
% P=[1 0.25;0.25 1];
% Q=[0.5 0.25;0.25 1.5];
xt = getGlobalx;
e = xt-x;
xmatrix=[(x(1)-x(1))^2,(x(2)-x(1))^2,(x(3)-x(1))^2,(x(4)-x(1))^2,(x(5)-x(1))^2,(x(6)-x(1))^2,(x(7)-x(1))^2,(x(8)-x(1))^2;
(x(1)-x(2))^2,(x(2)-x(2))^2,(x(3)-x(2))^2,(x(4)-x(2))^2,(x(5)-x(2))^2,(x(6)-x(2))^2,(x(7)-x(2))^2,(x(8)-x(2))^2;
(x(1)-x(3))^2,(x(2)-x(3))^2,(x(3)-x(3))^2,(x(4)-x(3))^2,(x(5)-x(3))^2,(x(6)-x(3))^2,(x(7)-x(3))^2,(x(8)-x(3))^2;
(x(1)-x(4))^2,(x(2)-x(4))^2,(x(3)-x(4))^2,(x(4)-x(4))^2,(x(5)-x(4))^2,(x(6)-x(4))^2,(x(7)-x(4))^2,(x(8)-x(4))^2;
(x(1)-x(5))^2,(x(2)-x(5))^2,(x(3)-x(5))^2,(x(4)-x(5))^2,(x(5)-x(5))^2,(x(6)-x(5))^2,(x(7)-x(5))^2,(x(8)-x(5))^2;
(x(1)-x(6))^2,(x(2)-x(6))^2,(x(3)-x(6))^2,(x(4)-x(6))^2,(x(5)-x(6))^2,(x(6)-x(6))^2,(x(7)-x(6))^2,(x(8)-x(6))^2;
(x(1)-x(7))^2,(x(2)-x(7))^2,(x(3)-x(7))^2,(x(4)-x(7))^2,(x(5)-x(7))^2,(x(6)-x(7))^2,(x(7)-x(7))^2,(x(8)-x(7))^2;
(x(1)-x(8))^2,(x(2)-x(8))^2,(x(3)-x(8))^2,(x(4)-x(8))^2,(x(5)-x(8))^2,(x(6)-x(8))^2,(x(7)-x(8))^2,(x(8)-x(8))^2];

% xmatrix=[(x(1)-x(1))^2,(x(2)-x(1))^2,(x(3)-x(1))^2,(x(4)-x(1))^2,(x(5)-x(1))^2;
% (x(1)-x(2))^2,(x(2)-x(2))^2,(x(3)-x(2))^2,(x(4)-x(2))^2,(x(5)-x(2))^2;
% (x(1)-x(3))^2,(x(2)-x(3))^2,(x(3)-x(3))^2,(x(4)-x(3))^2,(x(5)-x(3))^2;
% (x(1)-x(4))^2,(x(2)-x(4))^2,(x(3)-x(4))^2,(x(4)-x(4))^2,(x(5)-x(4))^2;
% (x(1)-x(5))^2,(x(2)-x(5))^2,(x(3)-x(5))^2,(x(4)-x(5))^2,(x(5)-x(5))^2];

% sigma=0.1; % 事件触发参数
% kappa=0.48;
% lambda=(1-sigma)*kappa;
% a=norm(A+B*K);
% theta=1/(2*a-lambda);
sum1=sum(A);
miu=(T/(T-t))^(h);  %时变函数的倒数？

% if ((rou/4)*A(1,:)*xmatrix(:,1)+sum1(1)*ant(1)*(miu)^-0.7)<(e(1)^2)  % 事件触发条件
%     setGlobalx(x); 
% %     xt = getGlobalx;
%      trigger_times_1=[trigger_times_1,t];%这里把触发时间记录成八条
% %     x1=[xt(1,:),x1];
% end
if t<2.0000

%% 
if (e(1)^2)>((rou/4)*A(1,:)*xmatrix(:,1)+sum1(1)*ant(1)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_1=[trigger_times_1,t];
end
if (e(2)^2)>((rou/4)*A(2,:)*xmatrix(:,2)+sum1(2)*ant(2)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_2=[trigger_times_2,t];
end
if (e(3)^2)>((rou/4)*A(3,:)*xmatrix(:,3)+sum1(3)*ant(3)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_3=[trigger_times_3,t];
end
if (e(4)^2)>((rou/4)*A(4,:)*xmatrix(:,4)+sum1(4)*ant(4)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_4=[trigger_times_4,t];
end
if (e(5)^2)>((rou/4)*A(5,:)*xmatrix(:,5)+sum1(5)*ant(5)*(miu)^-1.2)
     setGlobalx(x);
   trigger_times_5=[trigger_times_5,t];
end
if (e(6)^2)>((rou/4)*A(6,:)*xmatrix(:,6)+sum1(6)*ant(6)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_6=[trigger_times_6,t];
end
if (e(7)^2)>((rou/4)*A(7,:)*xmatrix(:,7)+sum1(7)*ant(7)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_7=[trigger_times_7,t];
end
if (e(8)^2)>((rou/4)*A(8,:)*xmatrix(:,8)+sum1(8)*ant(8)*(miu)^-1.2)
    setGlobalx(x);
    trigger_times_8=[trigger_times_8,t];
end
xt= getGlobalx;
% % L*(xtnew)
if t<1
    
    s=2*(t-1);
dx=-((k*h)/T)*((T/(T-t))^(h))^(1/h)*inv(H)*L*(xt)+s*inv(H)*gi;  %Eq 5 ？
% u=[u,dx];
else
    
dx=-((k*h)/T)*((T/(T-t))^(h))^(1/h)*inv(H)*L*(xt);
% u=[u,dx];
% deta=-lambda*eta+sigma*x'*Q*x-2*x'*P*B*K*e;
end

end


